(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{640:function(v,_,s){"use strict";s.r(_);var t=s(25),e=Object(t.a)({},(function(){var v=this,_=v.$createElement,s=v._self._c||_;return s("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[s("h1",{attrs:{id:"redis"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis"}},[v._v("#")]),v._v(" Redis")]),v._v(" "),s("h2",{attrs:{id:"计算机存储器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#计算机存储器"}},[v._v("#")]),v._v(" 计算机存储器")]),v._v(" "),s("p",[s("strong",[v._v("外存储器")]),v._v("（"),s("strong",[v._v("价格便宜")]),v._v("、容量大、"),s("strong",[v._v("读取速度慢（毫秒）")]),v._v("、断电后数据不会丢失）：存放暂时不用的程序和数据，通常是磁性介质，像硬盘、软盘、光盘、U盘、磁带等")]),v._v(" "),s("p",[s("strong",[v._v("内存储器")]),v._v("（"),s("strong",[v._v("价格贵")]),v._v("、容量小、"),s("strong",[v._v("读取速度快（纳秒）")]),v._v("、断电后数据会丢失）：存放立即要用的程序和数据，是外存与CPU进行沟通的桥梁，用于暂时存放CPU中的运算数据，与硬盘等外部存储器交换的数据")]),v._v(" "),s("p",[v._v("电脑程序一般安装在硬盘等外存上，运行时操作系统会把程序调入内存中运行，当我们使用Word处理文档，在键盘上敲入字符时，它被存入内存中；当选择保存时，内存中的数据才会被存入硬盘")]),v._v(" "),s("blockquote",[s("p",[s("strong",[v._v("如果全部数据存在硬盘上，随着文件变大，文件全量IO扫描速度会越来越慢")])])]),v._v(" "),s("h2",{attrs:{id:"为什么读mysql数据库数据比读文件数据快"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么读mysql数据库数据比读文件数据快"}},[v._v("#")]),v._v(" 为什么读Mysql数据库数据比读文件数据快")]),v._v(" "),s("p",[v._v("分治：数据文件中的数据，被格式化成一块块的数据页（data page）保存在硬盘中")]),v._v(" "),s("p",[v._v("索引：在内存中使用B+树，索引数据页数据，命中索引后把数据页从硬盘调到内存读取数据")]),v._v(" "),s("h2",{attrs:{id:"redis是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis是什么"}},[v._v("#")]),v._v(" Redis是什么")]),v._v(" "),s("p",[v._v("Redis是一种key-value结构的非关系型数据库，因为基于缓存所以读写速度非常快【纳秒级】，同时key有着过期淘汰策略，value还支持多种数据类型，Redis还拥有发布订阅和等特性，在分布式系统中常常被当作缓存中间件来使用")]),v._v(" "),s("h2",{attrs:{id:"为什么需要redis缓存数据"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要redis缓存数据"}},[v._v("#")]),v._v(" 为什么需要Redis缓存数据")]),v._v(" "),s("ul",[s("li",[s("strong",[v._v("加快接口响应速度")]),v._v("：从内存（Redis）读数据比从硬盘（数据库）上读数据快，如果碰到执行耗时久且不频繁变动的SQL，就特别适合将运行结果（"),s("strong",[v._v("热点数据")]),v._v("）放入Redis，后面的请求就去缓存中取，使请求能够迅速响应")]),v._v(" "),s("li",[s("strong",[v._v("减轻数据库高并发负担")]),v._v("：使用Redis做缓冲，让接口先访问Redis，如果没命中缓存再去读数据库，防止数据库因高并发出现的连接异常问题")])]),v._v(" "),s("h2",{attrs:{id:"为什么只用redis做缓存不做主数据库"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么只用redis做缓存不做主数据库"}},[v._v("#")]),v._v(" 为什么只用Redis做缓存不做主数据库")]),v._v(" "),s("ul",[s("li",[v._v("内存昂贵且有限，无法大量存储数据")]),v._v(" "),s("li",[v._v("由于断电内存数据会丢失，无法保证数据安全")]),v._v(" "),s("li",[v._v("key-value结构无法储存表之间有强关联的数据")]),v._v(" "),s("li",[v._v("没有类似SQL的查询引擎，无法完成数据关联查询")])]),v._v(" "),s("h2",{attrs:{id:"为什么不用map替代redis"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么不用map替代redis"}},[v._v("#")]),v._v(" 为什么不用Map替代Redis")]),v._v(" "),s("ul",[s("li",[v._v("Redis是分布式缓存，数据可以持久化保存；Map是本地缓存，每次项目重启Map数据会被释放掉，不能被其他进程共享，很难保证数据一致性")]),v._v(" "),s("li",[v._v("Redis有缓存过期机制而Map没有")]),v._v(" "),s("li",[v._v("Redis能使用的内存（几十G）比JVM分配给Map的内存（几G）多得多")])]),v._v(" "),s("h2",{attrs:{id:"怎么保证数据库与缓存数据的一致性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#怎么保证数据库与缓存数据的一致性"}},[v._v("#")]),v._v(" 怎么保证数据库与缓存数据的一致性")]),v._v(" "),s("p",[v._v("对于读操作：")]),v._v(" "),s("ul",[s("li",[v._v("读缓存")]),v._v(" "),s("li",[v._v("命中就返回缓存数据")]),v._v(" "),s("li",[v._v("没有命中就读数据库，更新缓存")])]),v._v(" "),s("p",[v._v("而对于更新操作有两种情况：")]),v._v(" "),s("ul",[s("li",[v._v("先更新数据库，再操作缓存（delete/set）")]),v._v(" "),s("li",[v._v("先操作缓存（delete/set），再更新数据库")])]),v._v(" "),s("h3",[v._v("从原子性角度来讲")]),v._v(" "),s("p",[v._v("如果第一步失败可以返回50x，第二步根本不会执行但如果是第一步成功，第二步失败；而如果是第一步成功，第二步失败时")]),v._v(" "),s("p",[s("strong",[v._v("先更新数据库，再操作缓存（delete/set）：")]),v._v(" 数据库里是新数据，而缓存里是旧数据，业务上无法接受，因为数据应该以数据库数据为准")]),v._v(" "),s("p",[s("strong",[v._v("先操作缓存（delete/set），再更新数据库：")])]),v._v(" "),s("ul",[s("li",[v._v("delete操作成功，数据库更新数据失败：缓存里没有数据，会去数据库找旧数据")]),v._v(" "),s("li",[v._v("set操作成功，数据库更新数据失败：缓存和数据库数据会不一致，所以不考虑")])]),v._v(" "),s("h3",[v._v("从线程安全角度来讲")]),v._v(" "),s("p",[s("strong",[v._v("先更新数据库，再操作缓存（delete/set）：")])]),v._v(" "),s("p",[v._v("当对缓存的操作是更新时")]),v._v(" "),s("ul",[s("li",[v._v("线程A更新数据库")]),v._v(" "),s("li",[v._v("线程B更新数据库")]),v._v(" "),s("li",[v._v("线程B更新缓存")]),v._v(" "),s("li",[v._v("线程A更新缓存")])]),v._v(" "),s("p",[v._v("此时缓存中存在脏数据，所以不考虑")]),v._v(" "),s("p",[v._v("当对缓存的操作是删除时")]),v._v(" "),s("ul",[s("li",[v._v("线程A查询数据库，得到旧值")]),v._v(" "),s("li",[v._v("线程B更新数据库")]),v._v(" "),s("li",[v._v("线程B删除缓存")]),v._v(" "),s("li",[v._v("线程A更新缓存")])]),v._v(" "),s("p",[v._v("上述情况很难出现，")]),v._v(" "),s("p",[v._v("因为更新数据库比读数据库操作要慢，")]),v._v(" "),s("p",[v._v("所以【线程B删缓存】要领先于【线程A更新缓存】概率特别低，但可以优化")]),v._v(" "),s("p",[s("strong",[v._v("先操作缓存（delete/set），再更新数据库：")])]),v._v(" "),s("p",[v._v("当对缓存的操作是删除时")]),v._v(" "),s("ul",[s("li",[v._v("线程A删除了缓存")]),v._v(" "),s("li",[v._v("线程B去读数据库，得到旧值")]),v._v(" "),s("li",[v._v("线程B将旧值写入缓存")]),v._v(" "),s("li",[v._v("线程A将新值写入数据库")])]),v._v(" "),s("p",[v._v("此时出现了数据库和缓存不一致的问题，但可以优化")]),v._v(" "),s("p",[v._v("当对缓存的操作是更新时")]),v._v(" "),s("ul",[s("li",[v._v("线程A更新了缓存")]),v._v(" "),s("li",[v._v("线程B更新了缓存")]),v._v(" "),s("li",[v._v("线程B更新了数据库")]),v._v(" "),s("li",[v._v("线程A更新了数据库")])]),v._v(" "),s("p",[v._v("此时缓存中存在脏数据，所以不考虑")]),v._v(" "),s("p",[s("strong",[v._v("因为更新缓存更容易造成数据不一致所以对于更新操作，应该淘汰缓存而不是更新缓存")])]),v._v(" "),s("ul",[s("li",[v._v("【先更新数据库，再淘汰缓存】在破坏原子性时表现优异")]),v._v(" "),s("li",[v._v("【先淘汰缓存，再更新数据库】在高并发场景下表现优异")])]),v._v(" "),s("p",[s("strong",[v._v("优化手段：")])]),v._v(" "),s("ul",[s("li",[v._v("延时双删（同步删+重复异步删）")]),v._v(" "),s("li",[v._v("databus（消息队列串行化）")]),v._v(" "),s("li",[v._v("canal配合binlog（消息队列串行化）")])]),v._v(" "),s("h2",{attrs:{id:"redis是单线程还是多线程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis是单线程还是多线程"}},[v._v("#")]),v._v(" Redis是单线程还是多线程")]),v._v(" "),s("p",[v._v("计算机执行程序时主要涉及到两个操作，分别是读写操作和计算操作")]),v._v(" "),s("ul",[s("li",[v._v("读写操作主要涉及到网络IO和磁盘IO")]),v._v(" "),s("li",[v._v("计算操作主要涉及到CPU")])]),v._v(" "),s("p",[v._v("Redis 6.0之前")]),v._v(" "),s("ul",[s("li",[v._v("网络IO模块和数据读写模块是在同一个线程进行")]),v._v(" "),s("li",[v._v("持久化储存模块和集群支持模块等其他模块是多线程的")])]),v._v(" "),s("img",{staticClass:"emo",attrs:{src:"/blog/images/IMG_8500.png"}}),v._v(" "),s("p",[v._v("由于Redis本身是基于内存操作，计算效率是纳秒级，所以不用引入多线程来提升Redis的CPU利用率；而Redis确实是属于IO密集型服务，确实需要提升IO的利用率，但这并不意味着只能引入多线程技术才能做到，因为多线程会带来很多复杂的并发问题，维护成本，和线程切换带来的性能开销，所以"),s("strong",[v._v("在 6.0 之前 Redis 选择了单线程多路复用IO技术来提升IO利用率")])]),v._v(" "),s("p",[v._v("而随着越来越复杂的业务员场景，为了支持更高的QPS而不去浪费Redis机器资源，2020年5月份，Redis正式推出了6.0版本，这个版本中有很多重要的新特性，其中的多线程特性就是用来突破网络IO瓶颈，毕竟多路复用的IO模型本质上仍然是同步阻塞型IO模型")]),v._v(" "),s("img",{staticClass:"emo",attrs:{src:"/blog/images/IMG_8501.png"}}),v._v(" "),s("blockquote",[s("p",[s("strong",[v._v("多线程使得网络处理的请求并发进行，大大的提升性能，除了可以减少由于网络 I/O 等待造成的影响，还可以充分利用 CPU 的多核优势，另外数据的执行还是单线程，所以没有线程安全问题")])])])])}),[],!1,null,null,null);_.default=e.exports}}]);