(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{635:function(v,_,e){"use strict";e.r(_);var i=e(25),a=Object(i.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"互动3d开发"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#互动3d开发"}},[v._v("#")]),v._v(" 互动3D开发")]),v._v(" "),e("img",{attrs:{id:"topImg",src:"/blog/images/IMG_9025.jpeg"}}),v._v(" "),e("h2",{attrs:{id:"前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[v._v("#")]),v._v(" 前言")]),v._v(" "),e("p",[v._v("目前大前端的方向大致有：网页、小程序、H5游戏、移动端、客户端、服务端、图形3D、AR/VR、音视频、人工智能、区块链等等。")]),v._v(" "),e("p",[v._v("随着5G的到来，所有的网页或者程序都会趋于图形化，游戏化，3D化，强交互的特性已经是一个产品必不可少的需求，前端工程师从此变成人机交互体验设计师，因此前端的图形3D未来将会是个热门方向。")]),v._v(" "),e("h2",{attrs:{id:"计算机图形学"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#计算机图形学"}},[v._v("#")]),v._v(" 计算机图形学")]),v._v(" "),e("p",[v._v("计算机图形学是研究怎样利用计算机来显示、生成和处理图形的原理、方法和技术的一门学科。")]),v._v(" "),e("p",[e("strong",[v._v("计算机图形学经历了三个历史阶段：")])]),v._v(" "),e("ul",[e("li",[v._v("建立学科阶段（50年代）\n"),e("ul",[e("li",[v._v("电子数字积分计算机")]),v._v(" "),e("li",[v._v("阴极射线管")]),v._v(" "),e("li",[v._v("半自动防空系统+光笔")]),v._v(" "),e("li",[v._v("MIT论文首次提出计算机图形学")])])]),v._v(" "),e("li",[v._v("光栅图形学阶段（70年代）\n"),e("ul",[e("li",[v._v("光栅扫描图形显示器")]),v._v(" "),e("li",[v._v("第一届SIGGRAPH计算机图形学交互技术学术会议")]),v._v(" "),e("li",[v._v("各种图形软件标准+图形系统")]),v._v(" "),e("li",[v._v("各种图形渲染技术")])])]),v._v(" "),e("li",[v._v("真实感图形学阶段（90年代）\n"),e("ul",[e("li",[v._v("工业化图形学标准OpenGL和DirectX")]),v._v(" "),e("li",[v._v("GPU图形处理器")]),v._v(" "),e("li",[v._v("建模更逼真、光线追踪算法、细节贴图、硬件提升")]),v._v(" "),e("li",[v._v("多元化+学科交叉")])])])]),v._v(" "),e("p",[e("strong",[v._v("图形学应用领域")])]),v._v(" "),e("ul",[e("li",[v._v("计算机辅助设计")]),v._v(" "),e("li",[v._v("虚拟现实环境")]),v._v(" "),e("li",[v._v("科学计算可视化")]),v._v(" "),e("li",[v._v("影片")]),v._v(" "),e("li",[v._v("游戏")])]),v._v(" "),e("p",[e("strong",[v._v("图形学研究方向")])]),v._v(" "),e("ul",[e("li",[v._v("造型技术")]),v._v(" "),e("li",[v._v("动作表情捕捉技术")]),v._v(" "),e("li",[v._v("真实感渲染技术")]),v._v(" "),e("li",[v._v("管线优化技术")]),v._v(" "),e("li",[v._v("图形学与深度学习技术")])]),v._v(" "),e("h2",{attrs:{id:"三维图形程序架构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三维图形程序架构"}},[v._v("#")]),v._v(" 三维图形程序架构")]),v._v(" "),e("ul",[e("li",[v._v("应用程序（CPU+着色器代码）")]),v._v(" "),e("li",[v._v("显卡驱动（OpenGL驱动或者DirectX驱动）")]),v._v(" "),e("li",[v._v("图形处理器（GPU）")]),v._v(" "),e("li",[v._v("帧缓冲存储器（帧缓存）")]),v._v(" "),e("li",[v._v("输入设备\n"),e("ul",[e("li",[v._v("穿孔纸")]),v._v(" "),e("li",[v._v("光笔")]),v._v(" "),e("li",[v._v("鼠标")]),v._v(" "),e("li",[v._v("触摸屏")]),v._v(" "),e("li",[v._v("数据手套")]),v._v(" "),e("li",[v._v("数据衣")]),v._v(" "),e("li",[v._v("力反馈器")])])]),v._v(" "),e("li",[v._v("显示设备\n"),e("ul",[e("li",[v._v("CRT显示器")]),v._v(" "),e("li",[v._v("平板显示器")]),v._v(" "),e("li",[v._v("液晶显示器")]),v._v(" "),e("li",[v._v("等离子体显示器")]),v._v(" "),e("li",[v._v("LED显示器")]),v._v(" "),e("li",[v._v("三维立体眼镜")]),v._v(" "),e("li",[v._v("头盔显示器")]),v._v(" "),e("li",[v._v("眼镜盒子")]),v._v(" "),e("li",[v._v("裸眼立体显示器")]),v._v(" "),e("li",[v._v("气体投影")])])]),v._v(" "),e("li",[v._v("输出设备\n"),e("ul",[e("li",[v._v("打印机")]),v._v(" "),e("li",[v._v("绘图仪")])])])]),v._v(" "),e("h2",{attrs:{id:"gpu渲染管线"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#gpu渲染管线"}},[v._v("#")]),v._v(" GPU渲染管线")]),v._v(" "),e("p",[v._v("渲染管线就是在给定虚拟相机、三维物体、光源、照明模式、纹理等等条件下，GPU生成一副二维图像的过程。")]),v._v(" "),e("p",[v._v("图形渲染管线分为三个阶段，第一个阶段由CPU完成，后两个阶段由GPU完成：")]),v._v(" "),e("ul",[e("li",[v._v("应用阶段：将绘制几何体所需的顶点、光照、摄像机位置、纹理数据参数输入到绘制管线的下一个阶段")]),v._v(" "),e("li",[v._v("几何阶段：将数据放入三维坐标系中，经过计算、透视角度变换、裁剪、光照着色映射到二维屏幕坐标系中，将各个数据输入到光栅化阶段\n"),e("ul",[e("li",[e("strong",[v._v("顶点着色器（可编程阶段）")]),v._v("：模型变换、视图变换、顶点着色")]),v._v(" "),e("li",[e("strong",[v._v("几何着色器、曲面细分着色器（可选编程阶段）")]),v._v("：顶点增删、曲面细分")]),v._v(" "),e("li",[v._v("裁剪（可配置阶段）：投影变换、裁剪")]),v._v(" "),e("li",[v._v("屏幕映射（固定）")])])]),v._v(" "),e("li",[v._v("光栅化阶段：根据变换投影过后的顶点、颜色、纹理坐标等数据，得到输出到屏幕每个像素的正确配色，输入到显存，最后打印到屏幕\n"),e("ul",[e("li",[v._v("三角形设置（固定）：顶点转换成三角形网格")]),v._v(" "),e("li",[v._v("三角形遍历（固定）：网格转换成像素点")]),v._v(" "),e("li",[e("strong",[v._v("片元着色器（可编程阶段）")]),v._v("：计算每一个片元的颜色值")]),v._v(" "),e("li",[v._v("逐片元操作（可配置阶段）：通过融合计算出每一个像素点的颜色值")])])])]),v._v(" "),e("h2",{attrs:{id:"向量"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#向量"}},[v._v("#")]),v._v(" 向量")]),v._v(" "),e("p",[v._v("向量是既有大小（长度）又有方向的量")]),v._v(" "),e("p",[v._v("向量表达形式：A = [[ x ],[ y ]] = (x,y)")]),v._v(" "),e("p",[v._v("单位向量（长度为1的向量）= 向量 / 向量长度，往往用来表示方向")]),v._v(" "),e("p",[v._v("几何意义中的加减法：三角形法则")]),v._v(" "),e("p",[v._v("代数意义中的加减法：坐标相加减")]),v._v(" "),e("h2",{attrs:{id:"齐次坐标"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#齐次坐标"}},[v._v("#")]),v._v(" 齐次坐标")]),v._v(" "),e("p",[v._v("齐次坐标是投影几何中的坐标系统")]),v._v(" "),e("p",[v._v("齐次坐标将原笛卡尔n维坐标扩展成n+1维坐标，如果是向量新添坐标为0，如果是坐标新添坐标为1")]),v._v(" "),e("p",[v._v("使用齐次坐标的好处：")]),v._v(" "),e("ul",[e("li",[v._v("区分坐标和位移向量")]),v._v(" "),e("li",[v._v("使变换方程能以单个变换矩阵形式表达")]),v._v(" "),e("li",[v._v("表示透视空间中无穷远的点")])]),v._v(" "),e("p",[v._v("在齐次坐标中：")]),v._v(" "),e("ul",[e("li",[v._v("位置 - 位置 = 位移")]),v._v(" "),e("li",[v._v("位置 + 位移 = 位置")]),v._v(" "),e("li",[v._v("位移 + 位移 = 位移")]),v._v(" "),e("li",[v._v("位置 + 位置 = 中点")])]),v._v(" "),e("h2",{attrs:{id:"点乘"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#点乘"}},[v._v("#")]),v._v(" 点乘")]),v._v(" "),e("p",[v._v("几何意义中的点乘：a * b =  向量a的长度 * 向量b的长度 * 两向量夹角余弦")]),v._v(" "),e("p",[v._v("代数意义中的点乘：a * b = (Xa,Ya,Za)"),e("em",[v._v("(Xb,Yb,Zb) = [[ Xa, Ya, Za]]")]),v._v("(Xb,Yb,Zb)=Xa"),e("em",[v._v("Xb+Ya")]),v._v("Yb+Za*Zb")]),v._v(" "),e("p",[v._v("点乘作用：")]),v._v(" "),e("ul",[e("li",[v._v("找到两个向量的夹角")]),v._v(" "),e("li",[v._v("判断两向量的方向性（同向、相反、垂直）")]),v._v(" "),e("li",[v._v("求出一个向量到另一个向量的投影")]),v._v(" "),e("li",[v._v("解构其中一个向量")])]),v._v(" "),e("h2",{attrs:{id:"叉乘"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#叉乘"}},[v._v("#")]),v._v(" 叉乘")]),v._v(" "),e("p",[v._v("两向量的叉乘生成一个新向量，方向垂直于两向量的平面：a x b = -b x a")]),v._v(" "),e("p",[v._v("几何意义中的叉乘：||a x b|| = 向量a的长度 * 向量b的长度 * 两向量夹角正弦")]),v._v(" "),e("p",[v._v("代数意义中的叉乘：a x b = (YaZb-YbZa,ZaXb-XaZb,XaYb-YaXb) = [[0, -Za, Ya], [Za, 0, -Xa],[-Ya, Xa, 0]]*(Xb,Yb,Zb)")]),v._v(" "),e("p",[v._v("叉乘作用：")]),v._v(" "),e("ul",[e("li",[v._v("判断两个向量的左右性")]),v._v(" "),e("li",[v._v("判断点是否在三角形内")])]),v._v(" "),e("h2",{attrs:{id:"矩阵"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#矩阵"}},[v._v("#")]),v._v(" 矩阵")]),v._v(" "),e("p",[v._v("矩阵的乘积：（M x N）（N x P）=（M x P）")]),v._v(" "),e("p",[v._v("[[1, 3],[5, 2],[0, 4]] * [[3, 6, 9, 4],[2, 7, 8, 3]]\n= [[9, 27, 33, 13],[19, 44, 61, 26],[8, 28, 32, 12]]")]),v._v(" "),e("p",[v._v("矩阵的转置：(AB)^T = B^T*A^T")]),v._v(" "),e("p",[v._v("[[1, 2], [3, 4], [5, 6]]^T = [[1, 3, 5], [2, 4, 6]]")]),v._v(" "),e("p",[v._v("逆矩阵：AA^(-1) = A^(-1)A = I")]),v._v(" "),e("p",[v._v("(AB)^(-1) = B^(-1)A^(-1)")]),v._v(" "),e("p",[v._v("R^(-1) = R^T")]),v._v(" "),e("p",[e("strong",[v._v("将三维空间中的物体变成一张二维图像，要经历模型(Model)变换、视图(View)变换、投影(Projection)变换")])]),v._v(" "),e("h2",{attrs:{id:"_2d模型变换矩阵"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2d模型变换矩阵"}},[v._v("#")]),v._v(" 2D模型变换矩阵")]),v._v(" "),e("p",[v._v("平移矩阵：[[1, 0, tx],[0, 1, ty],[0, 0, 1]]")]),v._v(" "),e("p",[v._v("缩放矩阵：[[sx, 0, 0],[0, sy, 0],[0, 0, 1]]")]),v._v(" "),e("p",[v._v("剪切矩阵：[[1, shx, 0],[shy, 1, 0],[0, 0, 1]]")]),v._v(" "),e("p",[v._v("旋转矩阵：[[cos(theta), -sin(theta), 0], [sin(theta), cos(theta), 0],[0, 0, 1]]")]),v._v(" "),e("p",[v._v("仿射矩阵：[[a1, a2, tx],[a3, a4, ty],[0, 0, 1]]")]),v._v(" "),e("h2",{attrs:{id:"视图变换矩阵"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#视图变换矩阵"}},[v._v("#")]),v._v(" 视图变换矩阵")]),v._v(" "),e("p",[v._v("Tview = [[1,0,0,-Xe],[0,1,0,-Ye],[0,0,1,-Ze],[0,0,0,1]]")]),v._v(" "),e("p",[v._v("Rview = [[Xgxt,Ygxt,Zgxt,0],[Xt,Yt,Zt,0],[X-g,Y-g,Z-g,0],[0,0,0,1]]")]),v._v(" "),e("p",[v._v("Mview = Rview * Tview")]),v._v(" "),e("h2",{attrs:{id:"投影变换矩阵"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#投影变换矩阵"}},[v._v("#")]),v._v(" 投影变换矩阵")]),v._v(" "),e("p",[v._v("Scale = [[2/(r-l),0,0,0],[0,2/(t-b),0,0],[0,0,2/(n-f),0],[0,0,0,1]]")]),v._v(" "),e("p",[v._v("Center = [[1,0,0,-(r+l)/2],[0,1,0,-(t+b)/2],[0,0,1,-(n+f)/2],[0,0,0,1]]")]),v._v(" "),e("p",[v._v("正交投影矩阵：Mortho = Scale * Center")]),v._v(" "),e("p",[v._v("Mpersp-ortho = [[n,0,0,0],[0,n,0,0],[0,0,n+f,-nf],[0,0,1,0]]")]),v._v(" "),e("p",[v._v("透视投影矩阵：Mpersp = Mortho * Mpersp-ortho")]),v._v(" "),e("p",[e("strong",[v._v("用 Mpersp-ortho 将锥体（frustum）挤压成长方体（cuboid）时，near和far的上任何点的z值不变，而对于near和far中间的任意点的z值在挤压时是会被挤向near还是挤向far还是不变？")])]),v._v(" "),e("p",[v._v("[x',y',z',1] = [x,y,z,1] * Mpersp-ortho = [nx,ny,(n+f)z-nf,z] = [nx/z,ny/z,n+f-nf/z,1]")]),v._v(" "),e("p",[v._v("z' = n+f-nf/z < z (z < 0), 所以锥体中的任意点在挤压时会被压向far")]),v._v(" "),e("h2",{attrs:{id:"光栅化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#光栅化"}},[v._v("#")]),v._v(" 光栅化")]),v._v(" "),e("p",[v._v("视口变换矩阵：Mviewport = [[width/2,0,0,width/2],[0,height/2,0,height/2],[0,0,1,0],[0,0,0,1]]")]),v._v(" "),e("p",[v._v("通过采样判断像素点中心是否在图形里，计算出图形所包含的像素点")]),v._v(" "),e("p",[v._v("for (let x = 0 ; x < width ; x++)\nfor (let y = 0 ; y < height ; y++)\nimage[x][y] = inside(tri, x+0.5, y+0.5)")]),v._v(" "),e("h2",{attrs:{id:"webgl概述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#webgl概述"}},[v._v("#")]),v._v(" WebGL概述")]),v._v(" "),e("p",[v._v("OpenGL架构委员会（OpenGL Architecture Review Board）制定了一种具备"),e("strong",[v._v("可移植性的2D/3D图形规范")]),v._v("叫OpenGL，该规范定义了用来操作图形和图片必须要有的函数API，使程序员不用直接跟GPU打交道，而是跟抽象出来的通用接口打交道，OpenGL规范定义的API内部实现由各个GPU厂商像AMD、Intel、Nvidia做的显卡驱动来实现并翻译成GPU指令来运行三维图形软件，除了OpenGL这一套API规范以外，还有其他图形API规范，比如Direct3D、Vulkan、Metal等等。OpenGL规范在与微软的Dirct3D规范激烈竞争中一度落后，之后被Khronos Group管理的精简OpenGL ES取代，发展迅猛。")]),v._v(" "),e("p",[v._v("GPU绘制图形的各方面能力都比CPU强，其中着色器Shader是运行在GPU上的程序，主要来处理和渲染图形，自定义渲染图形时的动画效果，CPU中OpenGL程序里编写的着色器代码通过接口传给GPU中的着色器并执行，编写着色器代码也就意味着"),e("strong",[v._v("面向GPU编程")]),v._v("，这也是客户端游戏开发的方式，着色器语言目前有基于OpenGL的GLSL ES（OpenGL Shading Language ES），基于Direct3D 的HLSL（High Level Shading Language），还有NVIDIA 公司的Cg（C for Graphic）语言等等。")]),v._v(" "),e("p",[v._v("WebGL是一套基于OpenGL ES规范封装的面向GPU编程的3D绘图DOM API，或者说是"),e("strong",[v._v("OpenGL浏览器端运行环境")]),v._v("，需要大量地配合色器语言GLSL ES（OpenGL Shading Language ES）在底层调用驱动上实现好的OpenGL绘图方法来控制GPU绘制图形，同时还依赖于H5的Canvas元素，用JS拿到从Canvas元素返回的WebGL3D绘图上下文对象才能调用WebGL绘图函数并配合着色器语言GLSL来绘图。")]),v._v(" "),e("p",[v._v("Canvas是H5新增的画布元素，可以通过Canvas选择的渲染上下文暴露的API直接在画布上绘图，渲染上下文主要有基于CanvasRenderingContext2D的2D上下文，也有基于WebGL的3D上下文，也有基于WebGL2的3D上下文。")]),v._v(" "),e("p",[e("strong",[v._v("Canvas2D固定渲染管线")]),v._v("不需要也不允许自定义顶点渲染和像素渲染的具体逻辑，它内部已经固化了一套完整的渲染流程，只需要开发者在CPU代码端输入渲染所需要的参数并指定特定的开关，就能完成不同的渲染；"),e("strong",[v._v("WebGL3D可编程渲染管线")]),v._v("使得开发者可以根据自己的具体需要来编写顶点渲染和像素渲染中的具体逻辑，可最大程度的简化渲染管线的逻辑以提高渲染效率，也可自己实现特定的算法和逻辑来渲染出固定管线无法渲染的效果，具有很高的可定制性，但同时也对开发者提出了更高的要求，关键点就在于"),e("strong",[v._v("着色器语言GLSL")]),v._v("的加入。")]),v._v(" "),e("h2",{attrs:{id:"three-js概述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#three-js概述"}},[v._v("#")]),v._v(" Three.js概述")]),v._v(" "),e("p",[v._v("直接使用WebGL编程还是很复杂的，编程者需要知道WebGL的底层细节，并且学习复杂的着色语言来获得WebGL的大部分功能。Three.js是一个对原生WebGL的封装库，同一个效果，用WebGL写需要280行代码，但使用Three.js只需要30行代码，他们的关系就好比Javascript和jQuery。Three.js提供了很多很简单的关于WebGL特性的JavaScript API，所以用户不需要详细地学习着色器语言，就能创作出好看的三维图形。")]),v._v(" "),e("h2",{attrs:{id:"three-js程序结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#three-js程序结构"}},[v._v("#")]),v._v(" Three.js程序结构")]),v._v(" "),e("ul",[e("li",[v._v("Scene场景")]),v._v(" "),e("li",[v._v("Geometry几何体\n"),e("ul",[e("li",[v._v("BoxGeometry立方体")]),v._v(" "),e("li",[v._v("SphereGeometry球体")]),v._v(" "),e("li",[v._v("CylinderGeometry圆柱")]),v._v(" "),e("li",[v._v("自定义几何体（BufferGeometry+BufferAttribute）")])])]),v._v(" "),e("li",[v._v("材质\n"),e("ul",[e("li",[v._v("点材质\n"),e("ul",[e("li",[v._v("PointsMaterial")])])]),v._v(" "),e("li",[v._v("线材质\n"),e("ul",[e("li",[v._v("LineBasicMaterial")]),v._v(" "),e("li",[v._v("LineDashedMaterial")])])]),v._v(" "),e("li",[v._v("网格材质\n"),e("ul",[e("li",[v._v("MeshBasicMaterial 不受光照影响")]),v._v(" "),e("li",[v._v("MeshLambertMaterial 漫反射")]),v._v(" "),e("li",[v._v("MeshPhongMaterial 镜面反射")]),v._v(" "),e("li",[v._v("MeshStandardMaterial 金属、玻璃等效果")])])]),v._v(" "),e("li",[v._v("精灵材质\n"),e("ul",[e("li",[v._v("SpriteMaterial")])])]),v._v(" "),e("li",[v._v("自定义着色器材质\n"),e("ul",[e("li",[v._v("RawShaderMaterial")]),v._v(" "),e("li",[v._v("ShaderMaterial")])])])])]),v._v(" "),e("li",[v._v("模型\n"),e("ul",[e("li",[v._v("Points点模型")]),v._v(" "),e("li",[v._v("Line线模型")]),v._v(" "),e("li",[v._v("Mesh网格模型")]),v._v(" "),e("li",[v._v("Sprite精灵模型")])])]),v._v(" "),e("li",[v._v("Light光源\n"),e("ul",[e("li",[v._v("PointLight点光源")]),v._v(" "),e("li",[v._v("AmbientLight环境光")]),v._v(" "),e("li",[v._v("DirectionalLight平行光")]),v._v(" "),e("li",[v._v("SpotLight聚光灯光源")])])]),v._v(" "),e("li",[v._v("Camera相机\n"),e("ul",[e("li",[v._v("OrthographicCamera正投影相机")]),v._v(" "),e("li",[v._v("PerspectiveCamera透视投影相机")])])]),v._v(" "),e("li",[v._v("Renderer渲染器")])]),v._v(" "),e("h2",{attrs:{id:"three-js常用方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#three-js常用方法"}},[v._v("#")]),v._v(" Three.js常用方法")]),v._v(" "),e("ul",[e("li",[v._v("Scene场景\n"),e("ul",[e("li",[v._v("add(object)")]),v._v(" "),e("li",[v._v("children")]),v._v(" "),e("li",[v._v("getChildByName(name)")]),v._v(" "),e("li",[v._v("remove(object)")]),v._v(" "),e("li",[v._v("traverse(func)")]),v._v(" "),e("li",[v._v("fog = new THREE.FogExp2(0xffffff,0.015)")]),v._v(" "),e("li",[v._v("overrideMaterial = new THREE.MeshLambertMaterial({color:0xffffff})")])])]),v._v(" "),e("li",[v._v("Geometry几何体\n"),e("ul",[e("li",[v._v("new THREE.Geometry()")]),v._v(" "),e("li",[v._v("vertices = [new THREE.Vector3(x,y,z)]")]),v._v(" "),e("li",[v._v("faces = [new THREE.Face3(x,y,z)]")]),v._v(" "),e("li",[v._v("computeCentroids()")]),v._v(" "),e("li",[v._v("mergeVertices()")]),v._v(" "),e("li",[v._v("verticesNeedUpdate")]),v._v(" "),e("li",[v._v("computeFaceNormals()")]),v._v(" "),e("li",[v._v("new THREE.PlaneGeometry(x,y,z)")]),v._v(" "),e("li",[v._v("new THREE.BoxGeometry(x,y,z)")]),v._v(" "),e("li",[v._v("new THREE.SphereGeometry(x,y,z)")]),v._v(" "),e("li",[v._v("clone()")])])]),v._v(" "),e("li",[v._v("Mesh网格\n"),e("ul",[e("li",[v._v("position.set(x,y,z) === position = new THREE.Vector3(x,y,z)")]),v._v(" "),e("li",[v._v("rotation.set(0.5"),e("em",[v._v("Math.PI,0,0) === rotation = new THREE.Vector3(0.5")]),v._v("Math.PI,0,0)")]),v._v(" "),e("li",[v._v("scale.set(x,y,z)")]),v._v(" "),e("li",[v._v("translate(n1,n2,n3)")]),v._v(" "),e("li",[v._v("visible")])])]),v._v(" "),e("li",[v._v("Camera相机\n"),e("ul",[e("li",[v._v("new THREE.OrthographicCamera(left,right,top,near,far)")]),v._v(" "),e("li",[v._v("new THREE.PerspectiveCamera(fov,aspect,near,far)")]),v._v(" "),e("li",[v._v("lookAt(x,y,z)")])])]),v._v(" "),e("li",[v._v("Light光源\n"),e("ul",[e("li",[v._v("new THREE.AmbientLight(0x440000)")]),v._v(" "),e("li",[v._v("new THREE.PointLight(0x440000)\n"),e("ul",[e("li",[v._v("color")]),v._v(" "),e("li",[v._v("intensity")]),v._v(" "),e("li",[v._v("distance")]),v._v(" "),e("li",[v._v("position")]),v._v(" "),e("li",[v._v("visible")])])]),v._v(" "),e("li",[v._v("new THREE.SpotLight(0x440000)\n"),e("ul",[e("li",[v._v("castShadow")]),v._v(" "),e("li",[v._v("target")]),v._v(" "),e("li",[v._v("angle")]),v._v(" "),e("li",[v._v("showCameraNear")]),v._v(" "),e("li",[v._v("showCameraFar")]),v._v(" "),e("li",[v._v("showCameraFov")])])]),v._v(" "),e("li",[v._v("new THREE.DirectionalLight(0x440000)")])])]),v._v(" "),e("li",[v._v("Material材料\n"),e("ul",[e("li",[v._v("new THREE.MeshBasicMaterial({color:0x440000})\n"),e("ul",[e("li",[v._v("color")]),v._v(" "),e("li",[v._v("wireframe")]),v._v(" "),e("li",[v._v("fog")]),v._v(" "),e("li",[v._v("visible")]),v._v(" "),e("li",[v._v("opacity")]),v._v(" "),e("li",[v._v("transparent")])])]),v._v(" "),e("li",[v._v("new THREE.MeshLambertMaterial({color: 0x7777ff})\n"),e("ul",[e("li",[v._v("ambient")]),v._v(" "),e("li",[v._v("emissive")])])]),v._v(" "),e("li",[v._v("new THREE.MeshPhongMaterial({color: 0x7777ff})\n"),e("ul",[e("li",[v._v("specular")]),v._v(" "),e("li",[v._v("shininess")])])]),v._v(" "),e("li",[v._v("new THREE.ShaderMaterial({fragmentShader,vertexShader})\n"),e("ul",[e("li",[v._v("uniforms")]),v._v(" "),e("li",[v._v("attributes")]),v._v(" "),e("li",[v._v("vertexShader")]),v._v(" "),e("li",[v._v("fragmentShader")])])])])])])])}),[],!1,null,null,null);_.default=a.exports}}]);