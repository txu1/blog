(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{637:function(t,s,a){"use strict";a.r(s);var r=a(25),v=Object(r.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"消息队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#消息队列"}},[t._v("#")]),t._v(" 消息队列")]),t._v(" "),a("h2",{attrs:{id:"消息队列是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#消息队列是什么"}},[t._v("#")]),t._v(" 消息队列是什么")]),t._v(" "),a("p",[t._v("消息队列是一种队列结构的中间件，能提供异步的服务通信方式，通常被当做存放数据的容器，需要的时候才会将里面的数据取出使用，在分布式系统中，数据【消息】通过消息队列在不同应用之间传输，其中把数据放进队列里的应用被称作生产者，把数据从队列里取出来的应用叫消费者")]),t._v(" "),a("h2",{attrs:{id:"为什么要使用消息队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么要使用消息队列"}},[t._v("#")]),t._v(" 为什么要使用消息队列")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("解耦")]),t._v("：上游服务只需把成功的消息放入消息队列，并不关心下游有多少服务依赖，下游只负责订阅监听成功的消息")]),t._v(" "),a("li",[a("strong",[t._v("异步")]),t._v("：将非必要的串行或者并行的下游服务逻辑放入消息队列异步运行，在防止高流量把数据库和缓存搞崩的同时加快接口响应速度")]),t._v(" "),a("li",[a("strong",[t._v("削峰")]),t._v("：为了防止流量过大导致服务挂掉，把请求放进消息队列，根据服务器处理能力来决定消费多少请求")])]),t._v(" "),a("h2",{attrs:{id:"消息队列有什么缺点？怎么解决"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#消息队列有什么缺点？怎么解决"}},[t._v("#")]),t._v(" 消息队列有什么缺点？怎么解决")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("重复消费")]),t._v(" "),a("ul",[a("li",[t._v("描述：由于消息队列的重试机制，下游服务只要出现异常就会让上游接口重新发送一次消息，比如：上游下单系统下单成功后，下游发卷系统出现异常，会让下单系统再次发送下单成功的消息，导致其他没报异常的下游服务重复消费这个下单成功的消息")]),t._v(" "),a("li",[t._v("解决：消费消息时确保接口的幂等性，无论执行多少次都要其返回结果都一样")])])]),t._v(" "),a("li",[a("strong",[t._v("顺序消费")]),t._v(" "),a("ul",[a("li",[t._v("描述：多个消息在被多个消费者消费时，会出现消息没有按照期望顺序消费，从而产生脏数据")]),t._v(" "),a("li",[t._v("解决：生产者根据hash把消息发送到同一个队列中，每个队列对应一个消费者")])])])])])}),[],!1,null,null,null);s.default=v.exports}}]);